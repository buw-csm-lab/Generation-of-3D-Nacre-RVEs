# -*- coding: mbcs -*-

#######################################################################################################################################
# reads in Voronoi data from a01_Nacre_2D_RVE and generates 3D nacre RVE in ABAQUS (including mesh)
# 
#
# 'dummy' material data is defined after line 156
# 
#######################################################################################################################################

from abaqus import *
from abaqusConstants import *
import __main__

import section
import regionToolset
import displayGroupMdbToolset as dgm
import part
import material
import assembly
import step
import interaction
import load
import mesh
import optimization
import job
import sketch
import visualization
import xyPlot
import displayGroupOdbToolset as dgo
import connectorBehavior
import random
import time
import os
import math
import random


# make all commands readable
session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE) 

#current working directory
wdir = str(os.getcwd())+'\\'
print wdir

global_bump_list=[]
bump_dia=0.1   
bump_h=0.1
num_bumb_per_layer=15

# Write a RVE border into a Set
def border_to_set(assembly_list,set_name,normal_border,point_on_border,c):
    for i in range(0,len(assembly_list),1):

        current_layer = Nacre_Model.rootAssembly.instances[assembly_list[i]]
        current_layer_border_face_seq_cur=[current_layer.faces[face.index:face.index+1]
        for face in current_layer.faces if  face.getNormal()== normal_border and face.pointOn[0][c] == point_on_border ]
        if i==0:
            current_layer_border_face_seq=current_layer_border_face_seq_cur
        else:
            current_layer_border_face_seq=current_layer_border_face_seq+current_layer_border_face_seq_cur    
    a = Nacre_Model.rootAssembly
    a.Set(faces=current_layer_border_face_seq, name=set_name) 
    

start = time.time()
print '****'
print 'Start of programm:'
print '****'
print '    '
print 'Current work directory:'
print os.getcwd()
print '    '
local_list=[]
# Import the input.txt which is generated by MatLab
input_file=wdir+'\_data\input.txt'
list_of_input = open(input_file,'r').readlines()   
t_matrix=float(list_of_input[0])
n_layer=int(list_of_input[1])
L_RVE=float(list_of_input[2])
t_cell=float(list_of_input[3])
L_cell=float(list_of_input[4])
t_matrix_layer=float(list_of_input[5])
var_rnd_points=float(list_of_input[6])

height_RVE=L_RVE
width_RVE=L_RVE
length_RVE=L_RVE

print(L_RVE)

#global parameters
border=[[0.,0.],[0.,width_RVE],[length_RVE,width_RVE],[length_RVE,width_RVE]]
global_list_node_py_border=[]
global_list_node_mx_border=[]
global_list_node_px_border=[]
global_list_node_my_border=[]
global_list_node_pz_border=[]
global_list_node_mz_border=[]
global_part_list=[]
tie_constrain_between_layer=[]
global_list_z_Sets=[]
global_list_z_Sets_asperities=[]
delete_coh_elem_pz_last_layer=[]


run=1
'''-------------------------------------------------------INPUT-------------------------------------------------------'''
#Input section
# Rotate each layer by 90°, if = 1
rotate_90=0


###################### Meshing ######################

# Include the meshing of the model:
meshing=1
# Create Shell Solids from single-wall cells
single_wall_shells=0;

# Define the element type
element_shape='hex_dom'          # options: hex_dom / tet
# Mesh parameters matrix:
mesh_matrix_size=t_cell/5.       # t_cell/2. #seeding
mesh_matrix_deviationFactor=0.1
mesh_matrix_minSizeFactor=0.1
# Mesh parameters cell:
mesh_cell_size=mesh_matrix_size
mesh_cell_deviationFactor=0.1
mesh_cell_minSizeFactor=0.1

# De-/activate .png output
output_img=0
img_data=TIFF

# Color of the solids
color_matrix='#D8D8D8'  #D8D8D8 --> 216, 216, 216
color_cell='#3104B4'    #3104B4 --> 49, 4, 180
color_name=color_matrix+'_'+color_cell


# Global parameters / lists
list_of_assemblies=[]
list_of_parts=[]

# Calculate the thickness of the polygons. Neccessary for extrusion in ABAQUS, because between each layer there will be a layer of matrix material
layer_thickness=t_cell+t_matrix_layer

#Create a model
name_model='Nacre'
mdb.models.changeKey(fromName='Model-1', toName=name_model)
Nacre_Model = mdb.Model(name=name_model)

    
#######################################################################################################################################
'''-------------------------------------------------------MATERIAL DEFINITION-------------------------------------------------------'''
#######################################################################################################################################
# Define material information
Nacre_Model.Material(name='Tablet material')
Nacre_Model.materials['Tablet material'].Elastic(table=((0.1, 0.3), )) # elastic modulus = 100 GPa
Nacre_Model.materials['Tablet material'].Density(table=((2.95e-15, ), )) # density is realistic
c_section_name='Mat_Section_tablet'
Nacre_Model.HomogeneousSolidSection(name=c_section_name, material='Tablet material', thickness=None)


# Mortar Material
Nacre_Model.Material(name='Mortar material')
mat=Nacre_Model.materials['Mortar material']
mat.Elastic(type=TRACTION, table=((0.004, 0.0008, 0.0008), )) # elastic modulus = 4 GPa
mat.MaxsDamageInitiation(table=((0.000025, 0.000025, 0.000025), ))
mat.maxsDamageInitiation.DamageEvolution(type=DISPLACEMENT, table=((0.001, ), ))
mat.Density(table=((1e-15, ), )) # density is realistic

#initialThicknessType=SPECIFY, initialThickness=0.02, 

#Define the Section
m_section_name='Mat_Section_matrix'
Nacre_Model.CohesiveSection(name=m_section_name, material='Mortar material', response=TRACTION_SEPARATION, outOfPlaneThickness=None)


'''-------------------------------------------------------CONSTRUCTION-------------------------------------------------------'''
a = Nacre_Model.rootAssembly

# Build a part for the matrix layer between the cell layers
s2 = Nacre_Model.ConstrainedSketch(name='__profile__', sheetSize=1.0)
g, v, d, c = s2.geometry, s2.vertices, s2.dimensions, s2.constraints
s2.setPrimaryObject(option=STANDALONE)
s2.rectangle(point1=(0.0, 0.0), point2=(L_RVE, L_RVE))
p = Nacre_Model.Part(name='p_matrix_layer', dimensionality=THREE_D, 
    type=DEFORMABLE_BODY)
p.BaseSolidExtrude(sketch=s2, depth=t_matrix_layer)

# Define the material to layer of matrix
region = p.Set(cells=p.cells, name='Set_matrix_layer')
p.SectionAssignment(region=region, sectionName=m_section_name, offset=0.0, 
    offsetType=MIDDLE_SURFACE, offsetField='', 
    thicknessAssignment=FROM_SECTION)
list_of_parts.append('p_matrix_layer')
print 'p_matrix_layer material added successfully.'

if run==1:
    # Loop builds up each each layer separated
    for i in range(1,n_layer+2,1):
        print ' '


        file_str=str(i)
        part_name='p_Layer_'+str(i)
        csys_name='layer_csys_'+str(i)
        print 'File_str: ',file_str
        
        # Define a part
        p = Nacre_Model.Part(name=part_name, dimensionality=THREE_D, type=DEFORMABLE_BODY)
        
        # Create a coordinate system
        origin_csys=(0.0, 0.0, 0.0)
        point1_csys=(L_RVE,0,0)
        point2_csys=(0,L_RVE,0)
        p.DatumCsysByThreePoints(origin=origin_csys, point1=point1_csys, point2=point2_csys, name=csys_name, coordSysType=CARTESIAN)
        # Create a principal plane
        p.DatumPlaneByPrincipalPlane(principalPlane=XYPLANE, offset=0.0)
        # Create principal axisDirection
        p.DatumAxisByPrincipalAxis(principalAxis=XAXIS)
        p.DatumAxisByPrincipalAxis(principalAxis=YAXIS)
        p.DatumAxisByPrincipalAxis(principalAxis=ZAXIS)
        
        if i != n_layer+1:
            # Import layer information from .txt files (generated by MatLab)
            poly_file_name=wdir+'_data\list_of_polygons_'+file_str+'.txt'
            elem_file_name=wdir+'_data\list_of_elements_'+file_str+'.txt'
            list_of_polygons = open(poly_file_name,'r').readlines()
            list_of_elements = open(elem_file_name,'r').readlines()    
            
            old_poly_file_name=wdir+'_data\list_of_old_polygons_'+file_str+'.txt'
            old_elem_file_name=wdir+'_data\list_of_old_elements_'+file_str+'.txt'
            list_of_old_polygons_1 = open(old_poly_file_name,'r').readlines()
            list_of_old_elements_1 = open(old_elem_file_name,'r').readlines()
            
            list_of_old_elements=[]
            for j in range(0,len(list_of_old_elements_1),1):
                list_of_old_elements_2=list_of_old_elements_1[j].replace('\n','')            
                list_of_old_elements_2=list_of_old_elements_2.split('\t')
                list_of_old_elements.append(list_of_old_elements_2)

            list_of_old_polygons=[]
            for j in range(0,len(list_of_old_polygons_1),1):
                list_of_old_polygons_2=list_of_old_polygons_1[j].replace('\n','')            
                list_of_old_polygons_2=list_of_old_polygons_2.split('\t')
                list_of_old_polygons.append(list_of_old_polygons_2)
        
        if i == 1:
            list_of_polygons_first=list_of_polygons
            list_of_elements_first=list_of_elements
            list_of_old_elements_first=list_of_old_elements
            list_of_old_polygons_first=list_of_old_polygons
            list_of_old_polygons_1_first=list_of_old_polygons_1
            list_of_old_elements_1_first=list_of_old_elements_1
            
        elif i == n_layer+1:
            list_of_polygons=list_of_polygons_first
            list_of_elements=list_of_elements_first
            list_of_old_elements=list_of_old_elements_first
            list_of_old_polygons=list_of_old_polygons_first
            list_of_old_elements_1=list_of_old_elements_1_first
            list_of_old_polygons_1=list_of_old_polygons_1_first
            
        # Every element (line between two vertices) of current layer will be plotted into a sketch

        # Define a sketch
        s = Nacre_Model.ConstrainedSketch(name='__profile__', sheetSize=1.0)
        g, v, d, c = s.geometry, s.vertices, s.dimensions, s.constraints
        
        for j in range(0,len(list_of_elements),1):
            line=list_of_elements[j]
            line=line.replace('\n','')
            line=line.split('\t')
            x1=float(line[1])
            y1=float(line[2])
            x2=float(line[3])
            y2=float(line[4])
            P1=[x1,y1]
            P2=[x2,y2]
            s.Line(point1=(x1,y1), point2=(x2,y2))
            
        # Extrude the layer of cells
        if i==1:
            t_cell=t_cell/2
        elif i==2:
            t_cell=t_cell*2
        
        p.BaseSolidExtrude(sketch=s, depth=t_cell)
        print part_name, 'modeled successfully.'
        del mdb.models['Nacre'].sketches['__profile__']
    
        # Create a geometry Set of all cells in this layer
        name_set_cells='Set_cells_'+part_name
        region_cells = p.Set(cells=p.cells, name=name_set_cells)
        name_set_cells_edges='Set_cells_edges_'+part_name
        p.Set(edges=p.edges, name=name_set_cells_edges)
        
        # Define the material to layer of cells
        p.SectionAssignment(region=region_cells, sectionName=c_section_name, offset=0.0, 
            offsetType=MIDDLE_SURFACE, offsetField='', 
            thicknessAssignment=FROM_SECTION)
        print part_name, 'material added successfully.'

        # Building a quadratic layer
        t = p.MakeSketchTransform(sketchPlane=p.datums[2], sketchUpEdge=p.datums[4], 
            sketchPlaneSide=SIDE1, sketchOrientation=LEFT, origin=(0, 0, 
            0.0))
        s1 = Nacre_Model.ConstrainedSketch(name='__profile__', 
            sheetSize=1, transform=t)
            
        g, v, d, c = s1.geometry, s1.vertices, s1.dimensions, s1.constraints
        s1.setPrimaryObject(option=SUPERIMPOSE)
        
        # Extrude the matrix material between the cells
        p.projectReferencesOntoSketch(sketch=s1, filter=COPLANAR_EDGES)
        s1.rectangle(point1=(0, 0), point2=(L_RVE, L_RVE))
        p.SolidExtrude(sketchPlane=p.datums[2], sketchUpEdge=p.datums[4], sketchPlaneSide=SIDE1, 
            sketchOrientation=LEFT, sketch=s1, depth=t_cell, 
            flipExtrudeDirection=OFF, keepInternalBoundaries=ON)
        s1.unsetPrimaryObject()
        del mdb.models['Nacre'].sketches['__profile__']
        
        # Create a geometry Set of everything in this layer
        name_set_all='Set_all_'+part_name
        name_set_all_edges_old='Set_all_edges_old_'+part_name
        Set_cur_part_all_cells=p.Set(cells=p.cells, name=name_set_all)
        p.Set(edges=p.edges, name=name_set_all_edges_old)
        
        # Create a geometry Set of the matrix in this layer
        name_set_matrix='Set_matrix_'+part_name
        p.SetByBoolean(name=name_set_matrix, operation=DIFFERENCE, sets=(p.sets[name_set_all], p.sets[name_set_cells], ))
        
        # Define the material to matrix in the layer of cells 
        p.SectionAssignment(region=p.sets[name_set_matrix], sectionName=m_section_name, offset=0.0, 
            offsetType=MIDDLE_SURFACE, offsetField='', 
            thicknessAssignment=FROM_SECTION)

        all_cur_edge=[]
        all_mid_point_cur_edge=[]
        # Cutting matrix into half-shell solids   
        if single_wall_shells==1:
            for k in range(0,len(list_of_old_polygons_1)):
                line=list_of_old_polygons_1[k]
                line=line.replace('\n','')            
                line=line.split('\t')
                t = p.MakeSketchTransform(sketchPlane=p.datums[2], sketchUpEdge=p.datums[4], 
                    sketchPlaneSide=SIDE1, sketchOrientation=LEFT, origin=(0, 0, 
                    0.0))
                s3 = Nacre_Model.ConstrainedSketch(name='__profile__', 
                    sheetSize=1, transform=t)
                g, v, d, c = s3.geometry, s3.vertices, s3.dimensions, s3.constraints
                p.projectReferencesOntoSketch(sketch=s3, filter=COPLANAR_EDGES)            
                
                for j in range(0,len(line)):

                    cur_element_num=int(line[j])
                    jj=1
                    index_of_cur_element_num=0
                    while cur_element_num != index_of_cur_element_num:
                        cur_element_line=list_of_old_elements[jj-1]
                        index_of_cur_element_num=int(cur_element_line[0])
                        jj=jj+1
                        
                    x1=float(float(cur_element_line[1]))
                    y1=float(float(cur_element_line[2]))
                    x2=float(float(cur_element_line[3]))
                    y2=float(float(cur_element_line[4]))

                    cur_edge=[x1,y1,x2,y2]
                    all_cur_edge.append(cur_edge)
                    
                    mid_point_cur_edge=[(x1+x2)/2,(y1+y2)/2]
                    if mid_point_cur_edge[0]!=0 and mid_point_cur_edge[1]!=0 and mid_point_cur_edge[0]!=L_RVE and mid_point_cur_edge[1]!=L_RVE:
                        all_mid_point_cur_edge.append(mid_point_cur_edge)
                    
                    s3.Line(point1=(x1,y1), point2=(x2,y2))
                    

                # Extrude the current inner polygon to a shell solid
                p.ShellExtrude(sketchPlane=p.datums[2], sketchUpEdge=p.datums[4], 
                    sketchPlaneSide=SIDE1, sketchOrientation=RIGHT, sketch=s3, depth=t_cell, flipExtrudeDirection=OFF, keepInternalBoundaries=ON)
                
                s3.unsetPrimaryObject()     
                del mdb.models['Nacre'].sketches['__profile__']
            
            # Delete multiple entries in "all_mid_point_cur_edge"
            l = all_mid_point_cur_edge
            x = []
            n = []
            for e in l:
                if e not in x:
                    n.append(e)
                    x.append(e)
            all_mid_point_cur_edge=n
      

        # Define that the midpoints (for finding the edges in the middle of matrix material) are the same on the split layer (first and last layer)        
        if i==1 and single_wall_shells==1:
            all_mid_point_cur_edge_layer_1=all_mid_point_cur_edge
        elif i==n_layer+1 and single_wall_shells==1:
            all_mid_point_cur_edge=all_mid_point_cur_edge_layer_1

        # Build the assembly of each part/layer
        assembly_name='a_cell_Layer_'+str(i)
        a = Nacre_Model.rootAssembly
        assembly=a.Instance(name=assembly_name, part=p, dependent=OFF)
    
        # Define the z-coordinate for moving the assemblies
        if i==1:
            z_coordinate_matrix_layer=t_cell
            z_coordinate_cell_layer=0
            p_last=p
        elif i==n_layer+1:
            # Give the first cell-layer an offset to the end of RVE
            assembly=a.Instance(name=assembly_name, part=p_last, dependent=OFF)
            t_cell=t_cell/2
            z_coordinate_cell_layer=height_RVE-t_cell
        else:
            z_coordinate_matrix_layer=(i*layer_thickness)-(t_cell/2)-t_matrix_layer
            z_coordinate_cell_layer=(i*layer_thickness)-(t_cell/2)-layer_thickness
            
        # Give each cell-layer an offset to create a stack of layers
        a.translate(instanceList=(assembly_name, ), vector=(0.0, 0.0, z_coordinate_cell_layer))
        print assembly_name, 'created successfully.'
        
        # Create/translate the assemblies of matrix between the cell layers 
        if i!=n_layer+1:
            assembly_name_matrix='a_matrix_Layer_'+str(i)
            a.regenerate()
            p1 = Nacre_Model.parts['p_matrix_layer']
            assembly_matrix=a.Instance(name=assembly_name_matrix, part=p1, dependent=OFF)
            a.translate(instanceList=(assembly_name_matrix, ), vector=(0.0, 0.0, z_coordinate_matrix_layer))
            print assembly_name_matrix, 'created successfully.'


        # Select a face in the middle of RVE
        bottomFace_cell_layer = assembly.faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_cell_layer),))
        topFace_matrix_layer = assembly_matrix.faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_matrix_layer+t_matrix_layer),))
        if i==n_layer+1:
            bottomFace_cell_layer = assembly.faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_cell_layer),))
            topFace_matrix_layer = assembly_matrix.faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_matrix_layer+t_matrix_layer),))
        topFace_cell_layer = a.instances[assembly_name].faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_cell_layer+t_cell),))
        bottomFace_matrix_layer = assembly_matrix.faces.findAt(((L_RVE/2,L_RVE/2,z_coordinate_matrix_layer),))        
        

        # Create a surface containing all faces within 45° to the face in the middle of RVE
        surf_name='Surface_top_cell_'+str(i)
        region_top_cell = Nacre_Model.rootAssembly.Surface(name=surf_name, side1Faces=(topFace_cell_layer[0].getFacesByFaceAngle(45)))
        surf_name='Surface_buttom_matrix_'+str(i)
        region_buttom_matrix = Nacre_Model.rootAssembly.Surface(name=surf_name, side1Faces=bottomFace_matrix_layer[0].getFacesByFaceAngle(45))

        surf_name='Surface_buttom_cell_'+str(i)
        region_buttom_cell = Nacre_Model.rootAssembly.Surface(name=surf_name, side1Faces=bottomFace_cell_layer[0].getFacesByFaceAngle(45))
        
        if i>1:
            # Define bottom tie constrains
            tie_bottom_name='Tie_buttom_'+str(i)
            Nacre_Model.Tie(name=tie_bottom_name, master=region_buttom_cell, slave=region_top_matrix, 
                positionToleranceMethod=COMPUTED, adjust=OFF, tieRotations=ON, 
                thickness=ON)
        surf_name='Surface_top_matrix_'+str(i)
        region_top_matrix = Nacre_Model.rootAssembly.Surface(name=surf_name, side1Faces=topFace_matrix_layer[0].getFacesByFaceAngle(45))
        if i<n_layer+1:
            # Define top tie constrains
            tie_top_name='Tie_top_'+str(i)
            Nacre_Model.Tie(name=tie_top_name, master=region_top_cell, slave=region_buttom_matrix, 
                positionToleranceMethod=COMPUTED, adjust=OFF, tieRotations=ON, 
                thickness=ON)
                
            # Add the assemblies of matrix layers to a global list    
            list_of_assemblies.append(assembly_name_matrix)

        # Add the parts and assemblies to a global list
        list_of_assemblies.append(assembly_name)
        list_of_parts.append(part_name)

        
        # Create a edge-Set of the midline of the matrix in this layer
        name_set_all_edges='Set_all_edges_'+part_name
        p.Set(edges=p.edges, name=name_set_all_edges)
        name_set_matrix_midline='Set_midline_edges_'+part_name
        hellyeah=p.SetByBoolean(name=name_set_matrix_midline, operation=DIFFERENCE, sets=(p.sets[name_set_all_edges], p.sets[name_set_all_edges_old], ))

        edge2=[]
        edge_index_list=[]
        set_name='Set_only_midlines'
        
        # print 'all_mid_point_cur_edge'
        # print all_mid_point_cur_edge
        print ' '
        
        for j in range(0,len(all_mid_point_cur_edge)):
            midpoint_cur_edge=all_mid_point_cur_edge[j]
            
             
            edge_index =mdb.models['Nacre'].rootAssembly.instances[assembly_name].edges.findAt((midpoint_cur_edge[0], midpoint_cur_edge[1],z_coordinate_cell_layer), ).index                                                             
                        
            edge4=mdb.models['Nacre'].rootAssembly.instances[assembly_name].edges[edge_index]
            edge2.append(edge4)

        print ' '
        '''-------------------------------------------------------DISCRETIZATION-------------------------------------------------------'''
        # if meshing==1:
            ################### Edges seeding ######################
            # a.seedEdgeBySize(edges=edge2, size=mesh_matrix_size, deviationFactor=mesh_matrix_deviationFactor, constraint=FINER)#constraint=FIXED

    
        if element_shape=='hex_dom':
            a.setMeshControls(regions=a.instances[assembly_name].cells, elemShape=HEX_DOMINATED, 
                technique=SWEEP, algorithm=ADVANCING_FRONT)
            elemType1 = mesh.ElemType(elemCode=C3D8R)
            elemType2 = mesh.ElemType(elemCode=C3D6)
            elemType3 = mesh.ElemType(elemCode=C3D4)

        elif element_shape=='tet':
            a.setMeshControls(regions=a.instances[assembly_name].cells, elemShape=TET, allowMapped=False, technique=FREE)
            elemType1 = mesh.ElemType(elemCode=C3D20R)
            elemType2 = mesh.ElemType(elemCode=C3D15)
            elemType3 = mesh.ElemType(elemCode=C3D10)

print '    '
print '****'
print 'End of construction:'
print '****'
print '    '            
end_construction = time.time()



# Mesh the layer (cell + matrix)
start_meshing=time.time()
###################### Global seeding ######################
all_part_Instances=[]
for i in range(0,len(list_of_assemblies),1):
    all_part_Instances.append(a.instances[list_of_assemblies[i]],)

a.seedPartInstance(regions=all_part_Instances, size=mesh_cell_size, minSizeFactor=mesh_cell_minSizeFactor)  #deviationFactor=mesh_cell_deviationFactor
a.setElementType(regions=Set_cur_part_all_cells, elemTypes=(elemType1, elemType2, elemType3))
a.generateMesh(regions=all_part_Instances)  
end_meshing=time.time()    


'''-------------------------------------------------------SETs-------------------------------------------------------'''
# Write a RVE border into a Set
print 'list_of_assemblies: ', list_of_assemblies
border_to_set(list_of_assemblies,'px_border',(1.0, 0.0, 0.0),length_RVE,0)
border_to_set(list_of_assemblies,'mx_border',(-1.0, 0.0, 0.0),(0),0)
border_to_set(list_of_assemblies,'py_border',(0, 1.0, 0.0),width_RVE,1)
border_to_set(list_of_assemblies,'my_border',(0, -1.0, 0.0),(0),1)
border_to_set(list_of_assemblies,'pz_border',(0, 0, 1.0),height_RVE,2)
border_to_set(list_of_assemblies,'mz_border',(0, -0, -1.0),(0),2)

'''-------------------------------------------------------OUTPUT-------------------------------------------------------'''

# Define orientation of a viewport
a.regenerate()

all_instances=Nacre_Model.rootAssembly.instances.keys()

session.viewports['Viewport: 1'].viewportAnnotationOptions.setValues(triad=ON, 
    compass=OFF)

# Rotate the hole assemby for a nice visual output
if output_img==1:
    a.rotate(instanceList=(all_instances), axisPoint=(0.0, 0.0, 0.0), 
        axisDirection=(L_RVE,0, 0.0), angle=-90.0)

# Make the datums invisible
session.viewports['Viewport: 1'].assemblyDisplay.geometryOptions.setValues(
    datumAxes=OFF, datumPlanes=OFF, datumCoordSystems=OFF)
 
# Output of input parameters
print '    '
print 'Geometrical input parameter:'
print 'L_RVE = ', L_RVE, 'µm'
print 'L_cell = ', L_cell, 'µm'
print 't_cell = ', t_cell, 'µm'
print 't_matrix: ', t_matrix, 'µm'
print 't_matrix_layer = ', t_matrix_layer, 'µm'
print 'var_rnd_points = ', var_rnd_points*100, '% of L_cell'
print 'n_layer: ', n_layer

# Define the displayed object
session.viewports['Viewport: 1'].setValues(displayedObject=a)

# Color the assembly   
session.viewports['Viewport: 1'].enableMultipleColors()  
cmap=session.viewports['Viewport: 1'].colorMappings['Section']
session.viewports['Viewport: 1'].setColor(colorMapping=cmap)    
session.viewports['Viewport: 1'].disableMultipleColors()

# Make viewport parallel
session.viewports['Viewport: 1'].view.setProjection(projection=PARALLEL)   

# Output image file .png
if output_img==1:
    r=random.randint(0,999999)
    img_name='pic/'+str(r)
    #img_name='pic/'+color_name
    print '     '
    print 'image file: ', img_name
    session.printOptions.setValues(vpDecorations=OFF)
    session.tiffOptions.setValues(imageSize=(1920, 1080))
    session.printToFile(
        fileName=img_name, 
        format=SVG, canvasObjects=(session.viewports['Viewport: 1'], ))
    img_name=img_name+'_1'
    session.printToFile(
        fileName=img_name, 
        format=TIFF, canvasObjects=(session.viewports['Viewport: 1'], ))


    
print '    '
print 'Construction time: ', end_construction-start, 'sec'
print 'Meshing time: ', end_meshing-start_meshing, 'sec'
# print 'Calculation time: ', end_calc-start_calc, 'sec'
end = time.time()
print 'Total time: ', end - start, 'sec'

print '    '
print '****'
print 'End of programm:'
print '****'
print '    '